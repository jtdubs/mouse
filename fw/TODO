Modes:
- Calibration mode:
  - Place mouse in center of box facing wall, let sensor calibrate against the "wall is present" values
  - Just accumulate 256 8-bit samples in a 16-bit counter, and keep the top byte
  - Consider only taking a sample every 10-20ms so it is averaged over a longer period of time (1-2s)
  - LED signal when done, or if failed
- Self-check mode:
  - Place mouse in center of box facing wall, with wheels off the ground
  - Turn on LEDs and confirm all sensors have a reading
  - Turn each wheel forward then backward a few revolutions to ensure encoders are working.
  - Confirm battery voltage in range
  - Have LED blink codes for error conditions
- Remote-control mode:
  - As-implemented
  - Eventually a "turn x degrees" and "move y mm" commands
  - Include wall-detection logic here and get rid of wall mode.

UI:
- Flatten Serial into Mouse
- Pull out Toolbar/Status/Symbols/etc. windows (similar to sim)
- Add maze UI and show mouse based on reported x,y,theta
- Write VCD file from reports

Firmware:
- On tick, update approximate x,y,theta based on encoder deltas
- Add x,y,theta to the report
- Add an x,y,theta controller on top of the position one
- Deal with encoder over/underflow

Sim:
- Auto-pause on collision or out-of-bounds
- Merge sim and ui app interfaces based on some structure representing the mouse state
  - For Sim it is populated based on simulare hardware events
  - For UI it is populated based on serial reports


Hardware:
- Tune speed and position pids on the actual motors
